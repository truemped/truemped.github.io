<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on all things considered...</title>
		<link>https://truemped.github.io/posts/</link>
		<description>Recent content in Posts on all things considered...</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Mon, 10 Jun 2019 16:25:00 +0200</lastBuildDate>
		<atom:link href="https://truemped.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>First Retrospection</title>
			<link>https://truemped.github.io/posts/retrospection/cw23/</link>
			<pubDate>Mon, 10 Jun 2019 16:25:00 +0200</pubDate>
			
			<guid>https://truemped.github.io/posts/retrospection/cw23/</guid>
			<description>I am trying different things at the moment about retro- or introspection for myself. One thing that I know others are doing are weekly mails to all their directs1. I&amp;rsquo;ve also seen this via some form of weekly blog post. My default working mode is transparency so why sending mails to only a few select people when I can also just give them the link. Whomever might be interested later might find this useful - or not.</description>
			<content type="html"><![CDATA[

<p>I am trying different things at the moment about retro- or introspection for
myself. One thing that I know others are doing are weekly mails to all their
<em>directs</em><sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>. I&rsquo;ve also seen this via some form of
weekly blog post. My default working mode is <strong>transparency</strong> so why sending
mails to only a few select people when I can also just give them the link.
Whomever might be interested later might find this useful - or not.</p>

<p>So I&rsquo;m giving this a try now.</p>

<h2 id="challenges">Challenges</h2>

<p>Meetings continue to be too many. At this point I&rsquo;m not sure if this is a
company wide problem or me being &ldquo;new&rdquo; to management and not saying <strong>no</strong>
enough. At one point this week I had a total of 10 meetings on one single day.
Obviously this is not sustainable.</p>

<p>A full-day offsite about the next company-wide re-org was intense. On one hand
simple things like the acoustic in the room was difficult and on the other hand
the topic was very important. The discussions have been very productive but also
intense. The devil is in the detail of course so how all of this will be
implemented is now crucial.</p>

<p>But also regarding the re-org I now for the first time I am not transparent
towards others. This is something I never really wanted to do but I do
acknowledge that sometimes it is better to not share information too early.
Everyone knows that the re-org will happen but the exact details are still
confidential.</p>

<h2 id="highlights">Highlights</h2>

<p>There are a number of different initiatives right now that I feel all share the
same technical solution. This week we started a proposal on how to tackle this
in a more structured way instead of adding hack over hack. It is not yet
finished and far from being able to be implemented, but at least we now share
similar understanding of the possible solution. I especially need to get my team
involved in the solution finding.</p>

<p>I have learned about <a href="https://medium.com/@mirceavlaicu/what-type-of-leader-are-you-a-multiplier-or-a-diminisher-1e2806428f6">multiplier and diminisher</a> type of leaders. It is
interesting how much a <em>lead</em><sup class="footnote-ref" id="fnref:2"><a href="#fn:2">2</a></sup> influences the team. A fairly recent episode
on the <em>Soft Skills Engineering</em> Podcast about
<a href="2" title="Not every *lead* is also a **leader**
">fighting the imposter syndrome</a> resonated a lot with me. In my opinion
everyone is subject to it except for diminishing leads maybe. In a similar kind
of manner the episode about <a href="https://www.greaterthancode.com/hope-and-suffering">hope and suffering</a> on the <em>Greater than Code</em>
Podcast was good. Essentially not everything is always great and suffering is
also an essential part of life.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">I hate the term &ldquo;direct&rdquo; but I don&rsquo;t know a better one. If you know one, please reach out
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">Not every <em>lead</em> is also a <strong>leader</strong>
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
</ol>
</div>
]]></content>
		</item>
		
		<item>
			<title>New Year Resolutions</title>
			<link>https://truemped.github.io/posts/new-year-resolutions-2019/</link>
			<pubDate>Wed, 23 Jan 2019 17:30:00 +0100</pubDate>
			
			<guid>https://truemped.github.io/posts/new-year-resolutions-2019/</guid>
			<description>So here I am, again claiming to stick to blogging. This time I&amp;rsquo;ll start with a look back at 2018 and my New Year resolutions that will make sure 2019 will be a blast.
Last year was a challenge for me as so many things happened that impacted my work-life. I transitioned into management and became Engineering Lead in the Search department at Zalando. I was surprised at how much I actually like working with people.</description>
			<content type="html"><![CDATA[

<p>So here I am, again claiming to stick to blogging. This time I&rsquo;ll start with a
look back at 2018 and my New Year resolutions that will make sure 2019 will be a
blast.</p>

<p>Last year was a challenge for me as so many things happened that impacted my
<strong>work-life</strong>. I transitioned into management and became <strong>Engineering Lead</strong> in
the Search department at Zalando. I was surprised at how much I actually like
working with people. In my life as individual contributor I was mostly writing
code and argued about it. Now I enjoy understanding someone else&rsquo;s motivation,
where she is coming from, what her goals are and how I might help her.</p>

<p>And honestly I also like the increased influence: talking to key people in the
organization earlier in the process helps me direct the course better. And
people tend to listen to me more open than before, which obviously is a strange
flaw in the organization. But that is a different topic.</p>

<p>I read a ton of books and blogs about transitioning. I liked
<a href="https://www.goodreads.com/book/show/33369254-the-manager-s-path">The Manager&rsquo;s Path</a> by Camille Fournier. I started reading
<a href="https://www.goodreads.com/book/show/1317946.Managing_Humans">Managing Humans</a> and have not yet finished. I did read some old time
classics even before like <a href="https://www.goodreads.com/book/show/21343.The_Five_Dysfunctions_of_a_Team">The five dysfunctions of a team</a>, a book you
should probably go through every once in a while. Another great classic is
<a href="https://www.goodreads.com/book/show/67825.Peopleware">Peopleware</a>, short and concise. <a href="https://www.goodreads.com/book/show/29939161-radical-candor">Radical Candor</a> is on the top of my
reading list. Lately I&rsquo;ve been involved in strategy topics and one great book in
this area is <a href="https://www.goodreads.com/book/show/11721966-good-strategy-bad-strategy">Good Strategy/Bad Strategy</a> with a lot of examples for good and
bad strategy.</p>

<p>I signed up for the <a href="https://softwareleadweekly.com/">Software Lead Weekly</a> newsletter and joined <a href="https://rands-leadership.slack.com/">Rands
Leadership Slack</a>. Particularly the <strong>face to face</strong> meetings are a great
experience as you get to speak to so many great people from all over the world
about leadership topics. Another benefit is that talking to external leaders
outside of one&rsquo;s organization brings a different, hopefully unbiased perspective
into your work.</p>

<p>But all of this came at a cost: I&rsquo;m not coding anymore. There are days when I
first open my Laptop after lunch. I had to learn to manage my calendar, block
time for lunch, otherwise people will just add meetings into empty spots.
Prioritization is even more important now as just about everyone wants something
from me.</p>

<h2 id="my-2019-goals">My 2019 Goals</h2>

<p>In this year I&rsquo;ll be working as manager for almost a full year now. I made
mistakes and I will continue to make them but I want to learn from them.</p>

<h3 id="keep-on-coding">Keep on Coding</h3>

<p>My job title is <em>Engineering</em> Lead. But how can I be an <em>Engineering Lead</em> when
I&rsquo;m not writing code? Or not participating in Code reviews? Architecture
decisions? That does not mean I need to make all the decisions or tell people
how to write code. But I don&rsquo;t want to loose grip. I think it is important to
feel the pain your engineers go through. This could mean taking a 24x7 shift
every once in a while. Or fixing a bug in one of our systems.</p>

<p>For now I&rsquo;m trying to maintain one of our Kafka Streams components written in
Clojure. I recently contributed patches to <a href="https://github.com/fundingcircle/jackdaw/">Jackdaw</a>, a Clojure wrapper for
Kafka Streams. It felt pretty good!</p>

<h3 id="writing-habit">Writing Habit</h3>

<p>I&rsquo;m also very passionate about good system architecture. Several of the
challenges my teams have today are because it&rsquo;s always easier to build programs
and not systems. That means it&rsquo;s always easier to write a couple of lines of
code and make <em>flag X</em> appear in the domain model. If we would instead focus on
writing code that enables a more general notion of how adding <em>flags</em> to the
domain model, we would not be adding more and more lines to the same code base
for new flags.</p>

<p>But in order to transport this into the wider organization it is essential to
write things down and share them. In the past I always tried to talk to people
and individually they often agree. But writing things down increases the
audience and hopefully influences more people. But this is something I need to
work on.</p>

<h3 id="learn-to-say-no">Learn to say no</h3>

<p><strong>No</strong> is a very powerful word. I cannot save everyone and everything. And
<strong>no</strong> brings me to my next and last goal:</p>

<h3 id="balance-my-life">Balance my life</h3>

<p>Paul Adams wrote an interesting piece on
<a href="https://medium.com/@padday/how-i-try-to-organise-my-life-to-make-me-happy-e521541d8691">How I try to organise my life to make me happy</a>. He has some interesting
points and formalizes what many people think. The idea originates from a speech
by <a href="https://youtu.be/BmCTQ_mkzHU">Matthew McConaughey</a> in 2015 and is about identifying the things that
matter to you and tracking the time spend doing them. Ideally there should be a
balance in all the areas in order to keep you healthy.</p>

<p>Identifying the things that matter to me is simple as they are exactly the same
as for Paul: Father, Husband, Family, Friend, Colleague, Me. I probably would
not go as far as mapping the results, but keeping track of them in my org-mode
files would be an even nerdier start.</p>

<p>That is pretty much it. Let&rsquo;s see what I will write in January 2020&hellip;</p>
]]></content>
		</item>
		
		<item>
			<title>Favorite Talks</title>
			<link>https://truemped.github.io/posts/favorite-talks/</link>
			<pubDate>Sun, 13 Jan 2019 10:00:00 +0100</pubDate>
			
			<guid>https://truemped.github.io/posts/favorite-talks/</guid>
			<description>Earlier this month Monica Lent published a list of Tech talks that&amp;rsquo;ll change how you think. Every one on this list is awesome and some have influenced me pretty heavily. Especially Simple made Easy by Rich Hickey. To these I&amp;rsquo;d like to add a few from my list of favorite talks.
Full Stack Awareness In this, Arthur Bergman rants about how everything is broken. We, as engineers, are so used to just connect a few systems and the new feature is working.</description>
			<content type="html"><![CDATA[

<p>Earlier this month Monica Lent published a list of
<a href="https://monicalent.com/blog/2019/01/01/favorite-programming-talks/">Tech talks that&rsquo;ll change how you think</a>. Every one on this list is awesome
and some have influenced me pretty heavily. Especially <a href="https://www.infoq.com/presentations/Simple-Made-Easy">Simple made Easy</a> by
Rich Hickey. To these I&rsquo;d like to add a few from my list of favorite talks.</p>

<h2 id="full-stack-awareness-1"><a href="https://youtu.be/oebqlzblfyo">Full Stack Awareness</a></h2>

<p>In this, Arthur Bergman rants about how everything is broken. We, as engineers,
are so used to just connect a few systems and the new feature is working. We
take so many things for granted that we forget how underlying systems down to
the operating system work.</p>


<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/oebqlzblfyo" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>


<h2 id="stop-rate-limiting-capacity-management-done-right-2"><a href="https://youtu.be/m64SWl9bfvk">Stop Rate Limiting! Capacity Management Done Right</a></h2>

<p>A very nice introduction into <a href="https://en.wikipedia.org/wiki/Little%27s_law">Little&rsquo;s Law</a> and how often times rate
limiting your backend is actually a bad idea. When protecting your backend
system usually you limit the RPS per customer. Initially you negotiate the rate
limits during onboarding and then forget about the exact numbers. In normal
operations you then discover that client A needs more RPS while client B needs
less. So you limit requests for client A even though you have spare capacity.</p>

<p>There is also a nice implementation of the algorithm in Elasticsearch called
<a href="https://www.elastic.co/blog/improving-response-latency-in-elasticsearch-with-adaptive-replica-selection">Adaptive Replica Selection</a> that we are using in production for a while now.</p>


<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/m64SWl9bfvk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>


<h2 id="how-not-to-measure-latency-4"><a href="https://youtu.be/lJ8ydIuPFeU">How NOT to Measure Latency</a></h2>

<p>Measuring and reporting latency is commonly based on percentiles. The problem
here is that we are happy with reporting this one data point for our system.
In today&rsquo;s Microservices architectures this is problematic though. A real user&rsquo;s
request usually triggers multiple calls to our backend systems. But that means
the chances of a user experiencing the p99 latency or even the maximum latency
is very high.</p>


<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/lJ8ydIuPFeU" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

]]></content>
		</item>
		
		<item>
			<title>Varnish All the Things</title>
			<link>https://truemped.github.io/posts/infra/varnish-all-the-things/</link>
			<pubDate>Mon, 01 Feb 2016 12:15:09 +0100</pubDate>
			
			<guid>https://truemped.github.io/posts/infra/varnish-all-the-things/</guid>
			<description>My usual web application stack for the past years was based on a nginx as reverse proxy in front of a number of Python processes. Static resources were served by nginx. Each Python process was stateless, state was stored in some kind of database. If the processes needed some shared ephemeral state like counters a local redis instance solved that. A battle tested common ground for Python based web applications.</description>
			<content type="html"><![CDATA[

<p>My usual web application stack for the past years was based on  a nginx as
reverse proxy in front of a number of Python processes. Static resources were
served by nginx. Each Python process was stateless, state was stored in some
kind of database. If the processes needed some shared ephemeral state like
counters a local redis instance solved that. A battle tested common ground for
Python based web applications.</p>

<p>What I have added to this lately was <a href="https://www.varnish-cache.org/">Varnish</a>,
a powerful proxying cache. The first that comes in mind could be &ldquo;there are two
problems in computer science: naming things and cache invalidation&rdquo;.  Agreed,
invalidation is tricky. But there are several tricks at hand that make this not
so bad at all.</p>

<p>Note: all examples should work with Varnish 4.0 and greater. If not, drop me a
line!</p>

<h3 id="caching-for-a-very-short-period">Caching for a very short period</h3>

<p>The first trick is to cache for only a very short amount of time, say 10
seconds or maybe even only 1:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Cache-Control: public, max-age<span class="o">=</span><span class="m">10</span></code></pre></div>
<p>Say you have a resource that is being hammered a lot and it should be &ldquo;near
real-time&rdquo;. Varnish will cache this response for 10 seconds. Now after the 10
seconds a new version must be computed. At this point Varnish will queue the
incoming requests and only forward one of them to the backend. All &ldquo;parked&rdquo;
requests will then get the response from the backend. Only one request to the
backend every 10 seconds, but there could be billions to Varnish that don&rsquo;t
bother you.</p>

<h3 id="grace-time">Grace time</h3>

<p>Say you chose to cache for only one second. Everything will be fine then if the
backend is able to compute a new version within one second. If it occasionally
takes longer then users will have to wait for the backend response. Having
users to wait is bad as you might be blocking the browser to render (which
you should be avoiding by other means!) or the user sees the loading symbol
even though all other elements are already loaded.</p>

<p>Here the grace time helps. It basically means that Varnish will return a stale
cache object until the backend is done computing the new version. So let&rsquo;s say
the backend sets this header:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Cache-Control: public, max-age<span class="o">=</span><span class="m">1</span></code></pre></div>
<p>In the Varnish VCL you then add:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sub vcl_backend_response <span class="o">{</span>
    <span class="nb">set</span> beresp.grace <span class="o">=</span> 1m<span class="p">;</span>
<span class="o">}</span></code></pre></div>
<p>This will allow your backend to take up to one minute to compute the new
version. During this time Varnish will deliver the old version to all incoming
requests. As soon as the backend is finished the new version will be delivered.</p>

<h3 id="grace-in-times-of-unhealthy-backends">Grace in times of unhealthy backends</h3>

<p>Grace time can also be extended in order to serve content while the backend is
down. For this you need to enable health checking for the backend like so:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">backend server1 <span class="o">{</span>
    .host <span class="o">=</span> <span class="s2">&#34;server1.example.com&#34;</span><span class="p">;</span>
    .probe <span class="o">{</span>
        .url <span class="o">=</span> <span class="s2">&#34;/_health&#34;</span><span class="p">;</span>
        .timeout <span class="o">=</span> 1s<span class="p">;</span>
        .interval <span class="o">=</span> 5s<span class="p">;</span>
        .window <span class="o">=</span> <span class="m">5</span><span class="p">;</span>
        .threshold <span class="o">=</span> <span class="m">3</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>This tells varnish to check the <strong>/_health</strong> endpoint every five seconds. The
backend needs to answer within one second. If three of the last five checks
were successful Varnish considers this backend to be healthy.</p>

<p>Now Varnish needs to detect failure and deliver stale content in order to have
some time fixing backends. For this we need to modify the <em>vcl_hit</em> method to
increase the grace time to a very large value during times no healthy backend
is available.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sub vcl_hit <span class="o">{</span>
    <span class="c1"># a cache hit</span>
    <span class="k">if</span> <span class="o">(</span>obj.ttl &gt;<span class="o">=</span> 0s<span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span>deliver<span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
    <span class="c1"># object is expired</span>
    <span class="k">if</span> <span class="o">(</span>std.healthy<span class="o">(</span>req.backend_hint<span class="o">))</span> <span class="o">{</span>
        <span class="c1"># but we have a healthy backend</span>
        <span class="k">if</span> <span class="o">(</span>obj.ttl + obj.grace &gt; 0s<span class="o">)</span> <span class="o">{</span>
            <span class="c1"># object is within the grace period</span>
            <span class="k">return</span> <span class="o">(</span>deliver<span class="o">)</span><span class="p">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1"># object is outside the grace persiod, fetch a new version</span>
            <span class="k">return</span><span class="o">(</span>fetch<span class="o">)</span><span class="p">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1"># no healthy backend available, deliver old version for two hours</span>
        <span class="k">if</span> <span class="o">(</span>obj.ttl + 2h &gt; 0s<span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span>deliver<span class="o">)</span><span class="p">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1"># after two hours we still have no healthy backend, now signal</span>
            <span class="c1"># the failure to the user</span>
            <span class="k">return</span> <span class="o">(</span>fetch<span class="o">)</span><span class="p">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>If you now manage to repair the backend within two hours the user will not
<em>see</em> the outage except maybe for old content.</p>

<h3 id="purging-the-cache">Purging the cache</h3>

<p>In order to remove a cache object a special HTTP verb can be used.  By simply
accessing the resource that should be removed with a <em>PURGE</em> verb, e.g.,
Varnish can dismiss the object. Again this is controlled in the VCL itself:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sub vcl_hit <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>req.request <span class="o">==</span> <span class="s2">&#34;PURGE&#34;</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">(</span>purge<span class="o">)</span><span class="p">;</span>
        <span class="k">return</span><span class="o">(</span>synth<span class="o">(</span><span class="m">200</span>, <span class="s2">&#34;Purged&#34;</span><span class="o">))</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
sub vcl_miss <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>req.request <span class="o">==</span> <span class="s2">&#34;PURGE&#34;</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">(</span>purge<span class="o">)</span><span class="p">;</span>
        <span class="k">return</span><span class="o">(</span>synth<span class="o">(</span><span class="m">200</span>, <span class="s2">&#34;Purged&#34;</span><span class="o">))</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>Now executing something like</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl -XPURGE <span class="s2">&#34;http://www.example.com/recent&#34;</span></code></pre></div>
<p>would purge the cached object. The next <strong>GET</strong> request issues a new fetch from
the backend. Obviously not everyone should be allowed to purge the cache so a
simple ACL with white listed IPs blocks unwanted access:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">acl purge <span class="o">{</span>
    <span class="s2">&#34;localhost&#34;</span><span class="p">;</span>
    <span class="c1"># add a list of allowed IPs here</span>
<span class="o">}</span></code></pre></div>
<p>Then use it to block access from any other machine:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sub vcl_hit <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>req.request <span class="o">==</span> <span class="s2">&#34;PURGE&#34;</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span>!client.ip ~ purge<span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">(</span>synth<span class="o">(</span><span class="m">405</span>, <span class="s2">&#34;Not allowed.&#34;</span><span class="o">))</span><span class="p">;</span>
        <span class="o">}</span>
        <span class="k">return</span><span class="o">(</span>purge<span class="o">)</span><span class="p">;</span>
        <span class="k">return</span><span class="o">(</span>synth<span class="o">(</span><span class="m">200</span>, <span class="s2">&#34;Purged&#34;</span><span class="o">))</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<h3 id="cache-invalidation-based-on-content">Cache invalidation based on content</h3>

<p>Sometimes invalidation based on URLs is not sufficient. Let&rsquo;s say one of the
articles from the big publishing house had to be removed for legal reasons and
you absolutely don&rsquo;t want to show it anymore. Invalidating the whole cache
would place quite some load on the backend. Maybe even too much load. In this
case banning objects based on its content enables one to only invalidate the
<em>affected</em> objects.</p>

<p>For this we need to introduce a custom HTTP response header from the backend.
This could be something like a list of article ids:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Content-Articles: <span class="m">1</span>,2,3,4,5</code></pre></div>
<p>Varnish will store this header along with the object. In order to invalidate
all cached objects containing article 3 an artificial endpoint in the VCL is
introduced:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sub vcl_recv <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>req.url ~ <span class="s2">&#34;/_ban&#34;</span> <span class="o">&amp;&amp;</span> req.method <span class="o">==</span> <span class="s2">&#34;BAN&#34;</span><span class="o">)</span> <span class="o">{</span>
        ban<span class="o">(</span><span class="s2">&#34;obj.http.Content-Articles ~ &#34;</span> + req.http.Ban-Article<span class="o">)</span><span class="p">;</span>
        <span class="k">return</span><span class="o">(</span>synth<span class="o">(</span><span class="m">204</span>, <span class="s2">&#34;NO CONTENT&#34;</span><span class="o">))</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>The request to ban article 3 would now be:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl -XBAN -H <span class="s1">&#39;Ban-Article: 3&#39;</span> <span class="s1">&#39;http://www.example.com/_ban&#39;</span></code></pre></div>
<p>Again securing via ACL is trivial and left out for clarity.</p>

<p>Banning works slightly different from purging. With purging the object is
removed instantly. For each call to ban, Varnish keeps a list of banning
statements that live for a longer period of time. When a cached object is
requested all of the banning statements are executed against the cached object.
If one matches, the object is fetched from the backend and not served. Once all
objects have been visited, the banned statement is removed.</p>

<p>In the case of rarely accessed objects, this might never happen. For this the
<strong>ban lurker</strong> thread will iterate over the otherwise missed objects and remove
them when necessary.</p>

<h3 id="conclusion">Conclusion</h3>

<p>I hope interest was raised if it has not been present so far. Varnish has
helped me a lot over the years and saved a lot of money by reducing the amount
of servers necessary for the individual project.</p>

<h4 id="resources">Resources</h4>

<ul>
<li><p><a href="https://www.varnish-cache.org/docs/4.0/">Varnish 4 documentation</a></p></li>

<li><p><a href="http://info.varnish-software.com/blog/grace-varnish-4-stale-while-revalidate-semantics-varnish">Grace time in Varnish 4</a></p></li>

<li><p><a href="https://www.varnish-cache.org/docs/4.0/users-guide/vcl-backends.html#health-checks">Health checks</a></p></li>

<li><p><a href="http://info.varnish-software.com/blog/ban-lurker">Ban lurker</a></p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Elasticsearch DSL-DSL</title>
			<link>https://truemped.github.io/posts/elastic-dsl/</link>
			<pubDate>Wed, 29 Jul 2015 10:19:47 +0100</pubDate>
			
			<guid>https://truemped.github.io/posts/elastic-dsl/</guid>
			<description>Elasticsearch is a search server based on Apache Lucene. As a developer it is easy to use, has an expressive query DSL and all is based on JSON serialization. Often though I find myself in a position where I need to adapt queries frequently and non-trivially, say in a demonstration in front of customers or product owners.
The questions are mostly similar: &amp;ldquo;what if I also filter for X&amp;rdquo;, &amp;ldquo;how does the ranking change, when I add a freshness function&amp;rdquo;, &amp;ldquo;do I get a better result if I boost document types Y&amp;rdquo; and so on.</description>
			<content type="html"><![CDATA[

<p>Elasticsearch is a search server based on Apache Lucene. As a developer it is
easy to use, has an expressive query DSL and all is based on JSON
serialization. Often though I find myself in a position where I need to adapt
queries frequently and non-trivially, say in a demonstration in front of
customers or product owners.</p>

<p>The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the
ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if
I boost document types Y&rdquo; and so on. While these are easy to add, two things
bother me: first, I need to come up with the queries during a presentation,
which adds pauses to the meetings. When I&rsquo;m finished with the query the
discussion has evolved. Second, I don&rsquo;t want to be the enabler. If they can
find out what they want without me it also means a faster feedback loop for
them. In brainstorming sessions it is easy to focus on arguments and skip the
sometimes lengthy query finding pauses. Win win for everyone it seems.</p>

<p>For this I have startet working on <strong>meta-DSLs</strong> for Elasticsearch projects.
The idea is simple: given a base query I want to be able to quickly alter or
enhance it using simple functions that are aligned with the mapping and index
structure. Given my current addiction towards Clojure, this is what I&rsquo;ve come
up with:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nv">query</span>
 <span class="p">(</span><span class="nv">freshness</span> <span class="s">&#34;1h&#34;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">tags</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span> <span class="s">&#34;sports&#34;</span><span class="p">])</span>
 <span class="p">(</span><span class="nv">prefer-category</span> <span class="p">{</span><span class="s">&#34;politics&#34;</span> <span class="mi">2</span>,
                   <span class="s">&#34;sports&#34;</span> <span class="mf">0.5</span><span class="p">}))</span></code></pre></div>
<p>Ok, it&rsquo;s not yet a graphical interface, but it is a start. And it&rsquo;s intuitive.
After demonstrating this to customers a few times they like it and request more
features. Their own feedback loop has shortened considerably. And the best of
it is that I am out of the loop and can focus on adding features.</p>

<p>In this example the domain will be news articles. They have a title, tags, a
published time and categories. Something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">{</span>
    <span class="ss">:title</span> <span class="s">&#34;The news&#34;</span>
    <span class="ss">:tags</span> <span class="p">[</span><span class="s">&#34;obama&#34;</span> <span class="s">&#34;kerry&#34;</span> <span class="s">&#34;merkel&#34;</span><span class="p">]</span>
    <span class="ss">:timestamp</span> <span class="s">&#34;2015-07-28T10:00:00Z&#34;</span>
    <span class="ss">:category</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>
<p>This post is my story of how I implemented this. Publishing this as a library
might be an idea but in the end all of this is tied to an exact mapping, index
structure and use case. If there is interest though, starting something similar
in a library could be interesting, if there is interest.</p>

<h2 id="dsls-in-clojure">DSLs in Clojure</h2>

<p>Creating a Domain Specific Language is pretty straight forward in Clojure
assuming you expose Clojure or Lisp syntax to the user. Using the clojure
reader and <code>eval</code> parsing a DSL into Clojure code is simple and defining the
DSL itself does then only involve implementing the functions.</p>

<p>In the next part I focus on the DSL implementation itself and the functions for
manipulating the query. In the last section, parsing and evaluating the DSL
into a real Elasticsearch query finishes.</p>

<h2 id="the-dsl">The DSL</h2>

<p>For the custom DSL I started with a base query structure upon which all other
functions build. It has four parts: query, scoring, filtering and aggregations:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">default-query</span>
 <span class="p">{</span><span class="ss">:query</span>
  <span class="p">{</span><span class="ss">:filtered</span>
   <span class="p">{</span><span class="ss">:query</span> <span class="p">{</span><span class="ss">:function_score</span> <span class="p">{</span><span class="ss">:query</span> <span class="p">{}</span>
                             <span class="ss">:functions</span> <span class="p">[]}}</span>
    <span class="ss">:filter</span> <span class="p">{</span><span class="ss">:bool</span> <span class="p">{</span><span class="ss">:must</span> <span class="p">[]</span>
                    <span class="ss">:must_not</span> <span class="p">[]}}}}</span>
  <span class="ss">:aggregations</span> <span class="p">{}})</span></code></pre></div>
<p>For all functions I am assuming the query to be the first argument in all
functions working with it. This simplifies the code later on as I can use the
<code>thread-first</code> macro to chain the individual function call.</p>

<p>Defining a function to add a <code>query</code> and for adding aggregations is straight
forward and does not even need a helper function:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn- </span><span class="nv">set-query</span>
 <span class="s">&#34;Given a valid ES query `q` add this to the generated query and return the
</span><span class="s">  new version.&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">q</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">query</span> <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:query</span> <span class="ss">:function_score</span> <span class="ss">:query</span><span class="p">]</span> <span class="nv">q</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">add-aggregation</span>
 <span class="s">&#34;Add a new aggregation to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">agg</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">query</span> <span class="p">[</span><span class="ss">:query</span> <span class="ss">:aggregations</span><span class="p">]</span> <span class="nv">agg</span><span class="p">))</span></code></pre></div>
<p>To work with this data structure a few helper methods come in handy when
developing the individual DSL functions. The first function helps when
manipulating lists in a nested map. Basically each scoring function or filter
needs to be added like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn- </span><span class="nv">append-in-nested-list</span>
 <span class="s">&#34;Given a map, append a new element to a nested  list.&#34;</span>
 <span class="p">[</span><span class="nv">q</span> <span class="nv">ks</span> <span class="nv">elm</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">q</span>                        <span class="c1">; the query</span>
           <span class="nv">ks</span>                       <span class="c1">; the list of keys in the query</span>
           <span class="p">(</span><span class="nb">apply conj </span>             <span class="c1">; append</span>
                  <span class="p">(</span><span class="nv">get-in</span> <span class="nv">q</span> <span class="nv">ks</span><span class="p">)</span>     <span class="c1">; to the list</span>
                  <span class="nv">elm</span><span class="p">)))</span>            <span class="c1">; the new element</span></code></pre></div>
<p>With this basic function adding more expressive functions to manipulate the
specific parts of the query are easy:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn- </span><span class="nv">add-function-score-function</span>
 <span class="s">&#34;Add a function score function to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">fs-function</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">append-in-nested-list</span> <span class="nv">query</span>
                        <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:query</span> <span class="ss">:function_score</span> <span class="ss">:functions</span><span class="p">]</span>
                        <span class="p">[</span><span class="nv">fs-function</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">add-must-filter</span>
 <span class="s">&#34;Add a must filter to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">must-filter</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">append-in-nested-list</span> <span class="nv">query</span>
                        <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:filter</span> <span class="ss">:bool</span> <span class="ss">:must</span><span class="p">]</span>
                        <span class="p">[</span><span class="nv">must-filter</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">add-must-not-filter</span>
 <span class="s">&#34;Add a must filter to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">must-filter</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">append-in-nested-list</span> <span class="nv">query</span>
                        <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:filter</span> <span class="ss">:bool</span> <span class="ss">:must_not</span><span class="p">]</span>
                        <span class="p">[</span><span class="nv">must-filter</span><span class="p">]))</span></code></pre></div>
<h3 id="dsl-functions">DSL functions</h3>

<p>The individual functions now basically compose the DSL. Being able to add
<code>(q &quot;merkel&quot;)</code> is translated into the following Clojure function:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">q</span>
  <span class="s">&#34;Simple query&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">user-query</span><span class="p">]</span>
  <span class="p">(</span><span class="nv">set-query</span> <span class="nv">query</span>
             <span class="p">{</span><span class="ss">:query_string</span> <span class="p">{</span><span class="ss">:query</span> <span class="nv">user-query</span>
                             <span class="ss">:default_operator</span> <span class="s">&#34;AND&#34;</span><span class="p">}}))</span></code></pre></div>
<p>Filtering for tags in our dataset (<code>(tags [&quot;merkel&quot;])</code>) is equally trivial:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">tags</span>
  <span class="s">&#34;Filter for a list of tags&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">tags</span><span class="p">]</span>
  <span class="p">(</span><span class="nv">add-must-filter</span> <span class="nv">query</span> <span class="p">{</span><span class="ss">:terms</span> <span class="p">{</span><span class="ss">:tags</span> <span class="nv">tags</span><span class="p">}}))</span></code></pre></div>
<p>Freshness seems more complicated but in the end I can simply add a function
score function using an [exponential decay](). With this the user can even
change parameters and see the effects:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">freshness</span>
  <span class="s">&#34;Add freshness preferences to the query. When called with query and hours as
</span><span class="s">   arguments&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">hours</span><span class="p">]</span>
  <span class="p">(</span><span class="nv">add-function-score-function</span> <span class="nv">query</span>
                               <span class="p">{</span><span class="ss">:exp</span> <span class="p">{</span><span class="ss">:publishTime</span> <span class="p">{</span><span class="ss">:decay</span> <span class="mf">0.9</span>
                                                    <span class="ss">:scale</span> <span class="nv">hours</span><span class="p">}}}))</span></code></pre></div>
<p>Prefering categories over other categories is another function score function.
Basically I add a boost (<code>weight</code>) to all documents matching a certain query:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">prefer-category</span>
  <span class="s">&#34;Prefer categories over all other categories.&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">category-preferences</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">nested-keys</span> <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:query</span> <span class="ss">:function_score</span> <span class="ss">:functions</span><span class="p">]</span>
        <span class="nv">functions</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nv">fn</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">{</span><span class="ss">:filter</span> <span class="p">{</span><span class="ss">:term</span> <span class="p">{</span><span class="ss">:category</span> <span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)}}</span>
                               <span class="ss">:weight</span> <span class="p">(</span><span class="nb">second </span><span class="nv">x</span><span class="p">)})</span>
                       <span class="p">(</span><span class="nb">seq </span><span class="nv">category-preferences</span><span class="p">))</span>
        <span class="nv">existing</span> <span class="p">(</span><span class="nv">get-in</span> <span class="nv">query</span> <span class="nv">nested-keys</span><span class="p">)]</span>
    <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">query</span> <span class="nv">nested-keys</span> <span class="p">(</span><span class="nb">apply conj </span><span class="nv">existing</span> <span class="nv">functions</span><span class="p">))))</span></code></pre></div>
<p>Aggregations help in understanding the data there is. Classical example in this
case would be getting the number of documents in the result set in a category.
In ES this is a simple terms aggregation:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">aggregate-categories</span>
 <span class="s">&#34;Aggregate the result by categories.&#34;</span>
 <span class="p">[</span><span class="nv">query</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">add-aggregation</span> <span class="nv">query</span> <span class="p">{</span><span class="ss">:terms</span> <span class="p">{</span><span class="ss">:field</span> <span class="ss">:category</span><span class="p">}}))</span></code></pre></div>
<p>To tie everything up I need to be able to wrap all functions into one
expression. For this I create a new macro called <code>query</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">query</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
<span class="o">`</span><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">default-query</span>
     <span class="o">~@</span><span class="nv">body</span><span class="p">))</span></code></pre></div>
<p>Using this macro a query can now be defined like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">simple-query</span> <span class="p">(</span><span class="nv">query</span>
                   <span class="p">(</span><span class="nv">q</span> <span class="s">&#34;test&#34;</span><span class="p">))</span></code></pre></div>
<h2 id="parsing-the-dsl">Parsing the DSL</h2>

<p>Doing this is Clojure is nice and easy for me but then again I want the PO not
to contact me about getting into the repl. So in the final step I need a
function that converts a string to Clojure code. First I need to parse the
string using <code>read-string</code> and then I can <code>eval</code> the resulting code. For this
to work as expected I need to set the special var <code>*ns*</code> to the namespace of my
DSL functions above using the <code>the-ns</code> function.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">demo.dsl</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">dsl</span>
 <span class="s">&#34;Compile the DSL string into code&#34;</span>
 <span class="p">[</span><span class="nv">dsl-string</span><span class="p">]</span>
 <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*ns*</span> <span class="p">(</span><span class="nv">the-ns</span> <span class="ss">&#39;demo.dsl-functions</span><span class="p">)</span>
           <span class="nv">*read-eval*</span> <span class="nv">false</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nv">read-string</span> <span class="nv">dsl-string</span><span class="p">))))</span></code></pre></div>
<p>The <code>binding</code> form binds the special var <code>*ns*</code> to the namespace containing my
dsl functions. I also bind <code>*read-eval*</code> to false and by this disable the
<code>eval</code> function inside the string. The parsed string will have access to all
functions declared in there. <code>read-string</code> converts a string into Clojure code
and <code>eval</code> will execute it. In this case it will simply return the final
Elasticsearch query.</p>

<h2 id="result">Result</h2>

<p>In essence this allows me to have a web frontend where a user can input
the query from the beginning</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nv">query</span>
 <span class="p">(</span><span class="nv">freshness</span> <span class="s">&#34;1h&#34;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">tags</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span> <span class="s">&#34;sports&#34;</span><span class="p">])</span>
 <span class="p">(</span><span class="nv">prefer-category</span> <span class="p">{</span><span class="s">&#34;politics&#34;</span> <span class="mi">2</span>,
                   <span class="s">&#34;sports&#34;</span> <span class="mf">0.5</span><span class="p">}))</span></code></pre></div>
<p>get back the equivalent Elasticsearch query:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:query</span>
 <span class="p">{</span><span class="ss">:filtered</span>
  <span class="p">{</span><span class="ss">:query</span>
   <span class="p">{</span><span class="ss">:function_score</span>
    <span class="p">{</span><span class="ss">:query</span> <span class="p">{}</span>,
     <span class="ss">:functions</span>
     <span class="p">[{</span><span class="ss">:exp</span> <span class="p">{</span><span class="ss">:publishTime</span> <span class="p">{</span><span class="ss">:decay</span> <span class="mf">0.9</span>, <span class="ss">:scale</span> <span class="s">&#34;1h&#34;</span><span class="p">}}}</span>
      <span class="p">{</span><span class="ss">:filter</span> <span class="p">{</span><span class="ss">:term</span> <span class="p">{</span><span class="ss">:category</span> <span class="s">&#34;politics&#34;</span><span class="p">}}</span>, <span class="ss">:weight</span> <span class="mi">2</span><span class="p">}</span>
      <span class="p">{</span><span class="ss">:filter</span> <span class="p">{</span><span class="ss">:term</span> <span class="p">{</span><span class="ss">:category</span> <span class="s">&#34;sports&#34;</span><span class="p">}}</span>, <span class="ss">:weight</span> <span class="mf">0.5</span><span class="p">}]}}</span>,
   <span class="ss">:filter</span>
   <span class="p">{</span><span class="ss">:bool</span>
    <span class="p">{</span><span class="ss">:must</span> <span class="p">[{</span><span class="ss">:terms</span> <span class="p">{</span><span class="ss">:tags</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span> <span class="s">&#34;sports&#34;</span><span class="p">]}}]</span>, <span class="ss">:must_not</span> <span class="p">[]}}}}</span>,
 <span class="ss">:aggregations</span> <span class="p">{}}</span></code></pre></div>
<p>which I can execute in the backend and display the results. With all the domain
functions in place I can then keep on improving the DSL or the frontend and
enable the PO to experiment at lot easier without my direct involvement, at
least in parts that I am not really interested in.</p>
]]></content>
		</item>
		
	</channel>
</rss>
