<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Daniel Truemper">
    <meta name="description" content="Daniel Truemper&#39;s personal space">
    <meta name="keywords" content="blog,developer,personal,engineering management,leadership">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Elasticsearch DSL-DSL"/>
<meta name="twitter:description" content="Elasticsearch is a search server based on Apache Lucene. As a developer it is easy to use, has an expressive query DSL and all is based on JSON serialization. Often though I find myself in a position where I need to adapt queries frequently and non-trivially, say in a demonstration in front of customers or product owners.
The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if I boost document types Y&rdquo; and so on."/>

    <meta property="og:title" content="Elasticsearch DSL-DSL" />
<meta property="og:description" content="Elasticsearch is a search server based on Apache Lucene. As a developer it is easy to use, has an expressive query DSL and all is based on JSON serialization. Often though I find myself in a position where I need to adapt queries frequently and non-trivially, say in a demonstration in front of customers or product owners.
The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if I boost document types Y&rdquo; and so on." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://truemped.github.io/posts/search/elastic-dsl/" />
<meta property="article:published_time" content="2015-07-29T10:19:47+01:00" />
<meta property="article:modified_time" content="2015-07-29T10:19:47+01:00" />


    
      <base href="https://truemped.github.io/posts/search/elastic-dsl/">
    
    <title>
  Elasticsearch DSL-DSL · all things considered...
</title>

    
      <link rel="canonical" href="https://truemped.github.io/posts/search/elastic-dsl/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://truemped.github.io/css/coder.min.a4f332213a21ce8eb521670c614470c58923aaaf385e2a73982c31dd7642decb.css" integrity="sha256-pPMyITohzo61IWcMYURwxYkjqq84XipzmCwx3XZC3ss=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="https://truemped.github.io/css/coder-dark.min.83a2010dac9f59f943b3004cd6c4f230507ad036da635d3621401d42ec4e2835.css" integrity="sha256-g6IBDayfWflDswBM1sTyMFB60DbaY102IUAdQuxOKDU=" crossorigin="anonymous" media="screen" />
      
    

    

    

    

    <link rel="icon" type="image/png" href="https://truemped.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://truemped.github.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.68.3" />
  </head>

  
  
    
  
  <body class="colorscheme-auto">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://truemped.github.io/">
      all things considered...
    </a>
    
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://truemped.github.io/posts/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://truemped.github.io/about/">About Me</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://truemped.github.io/how-to-daniel/">How to: Daniel</a>
          </li>
        
      
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Elasticsearch DSL-DSL</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2015-07-29T10:19:47&#43;01:00'>
                July 29, 2015
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              7-minute read
            </span>
          </div>
          
          <div class="tags">
  <i class="fas fa-tag"></i>
    <a href="https://truemped.github.io/tags/clojure/">clojure</a>
      <span class="separator">•</span>
    <a href="https://truemped.github.io/tags/elasticsearch/">elasticsearch</a>
      <span class="separator">•</span>
    <a href="https://truemped.github.io/tags/search/">search</a></div>

        </div>
      </header>

      <div>
        
        <p>Elasticsearch is a search server based on Apache Lucene. As a developer it is
easy to use, has an expressive query DSL and all is based on JSON
serialization. Often though I find myself in a position where I need to adapt
queries frequently and non-trivially, say in a demonstration in front of
customers or product owners.</p>
<p>The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the
ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if
I boost document types Y&rdquo; and so on. While these are easy to add, two things
bother me: first, I need to come up with the queries during a presentation,
which adds pauses to the meetings. When I&rsquo;m finished with the query the
discussion has evolved. Second, I don&rsquo;t want to be the enabler. If they can
find out what they want without me it also means a faster feedback loop for
them. In brainstorming sessions it is easy to focus on arguments and skip the
sometimes lengthy query finding pauses. Win win for everyone it seems.</p>
<p>For this I have startet working on <strong>meta-DSLs</strong> for Elasticsearch projects.
The idea is simple: given a base query I want to be able to quickly alter or
enhance it using simple functions that are aligned with the mapping and index
structure. Given my current addiction towards Clojure, this is what I&rsquo;ve come
up with:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(query
 (freshness <span style="color:#0ff;font-weight:bold">&#34;1h&#34;</span>)
 (tags [<span style="color:#0ff;font-weight:bold">&#34;politics&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;sports&#34;</span>])
 (prefer-category {<span style="color:#0ff;font-weight:bold">&#34;politics&#34;</span> <span style="color:#ff0;font-weight:bold">2</span>,
                   <span style="color:#0ff;font-weight:bold">&#34;sports&#34;</span> <span style="color:#ff0;font-weight:bold">0.5</span>}))
</code></pre></div><p>Ok, it&rsquo;s not yet a graphical interface, but it is a start. And it&rsquo;s intuitive.
After demonstrating this to customers a few times they like it and request more
features. Their own feedback loop has shortened considerably. And the best of
it is that I am out of the loop and can focus on adding features.</p>
<p>In this example the domain will be news articles. They have a title, tags, a
published time and categories. Something like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">{
    <span style="color:#0ff;font-weight:bold">:title</span> <span style="color:#0ff;font-weight:bold">&#34;The news&#34;</span>
    <span style="color:#0ff;font-weight:bold">:tags</span> [<span style="color:#0ff;font-weight:bold">&#34;obama&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;kerry&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;merkel&#34;</span>]
    <span style="color:#0ff;font-weight:bold">:timestamp</span> <span style="color:#0ff;font-weight:bold">&#34;2015-07-28T10:00:00Z&#34;</span>
    <span style="color:#0ff;font-weight:bold">:category</span> [<span style="color:#0ff;font-weight:bold">&#34;politics&#34;</span>]
}
</code></pre></div><p>This post is my story of how I implemented this. Publishing this as a library
might be an idea but in the end all of this is tied to an exact mapping, index
structure and use case. If there is interest though, starting something similar
in a library could be interesting, if there is interest.</p>
<h2 id="dsls-in-clojure">DSLs in Clojure</h2>
<p>Creating a Domain Specific Language is pretty straight forward in Clojure
assuming you expose Clojure or Lisp syntax to the user. Using the clojure
reader and <code>eval</code> parsing a DSL into Clojure code is simple and defining the
DSL itself does then only involve implementing the functions.</p>
<p>In the next part I focus on the DSL implementation itself and the functions for
manipulating the query. In the last section, parsing and evaluating the DSL
into a real Elasticsearch query finishes.</p>
<h2 id="the-dsl">The DSL</h2>
<p>For the custom DSL I started with a base query structure upon which all other
functions build. It has four parts: query, scoring, filtering and aggregations:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">def </span>default-query
 {<span style="color:#0ff;font-weight:bold">:query</span>
  {<span style="color:#0ff;font-weight:bold">:filtered</span>
   {<span style="color:#0ff;font-weight:bold">:query</span> {<span style="color:#0ff;font-weight:bold">:function_score</span> {<span style="color:#0ff;font-weight:bold">:query</span> {}
                             <span style="color:#0ff;font-weight:bold">:functions</span> []}}
    <span style="color:#0ff;font-weight:bold">:filter</span> {<span style="color:#0ff;font-weight:bold">:bool</span> {<span style="color:#0ff;font-weight:bold">:must</span> []
                    <span style="color:#0ff;font-weight:bold">:must_not</span> []}}}}
  <span style="color:#0ff;font-weight:bold">:aggregations</span> {}})
</code></pre></div><p>For all functions I am assuming the query to be the first argument in all
functions working with it. This simplifies the code later on as I can use the
<code>thread-first</code> macro to chain the individual function call.</p>
<p>Defining a function to add a <code>query</code> and for adding aggregations is straight
forward and does not even need a helper function:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn- </span>set-query
 <span style="color:#0ff;font-weight:bold">&#34;Given a valid ES query `q` add this to the generated query and return the
</span><span style="color:#0ff;font-weight:bold">  new version.&#34;</span>
 [query q]
 (assoc-in query [<span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:filtered</span> <span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:function_score</span> <span style="color:#0ff;font-weight:bold">:query</span>] q))

(<span style="color:#fff;font-weight:bold">defn- </span>add-aggregation
 <span style="color:#0ff;font-weight:bold">&#34;Add a new aggregation to the query&#34;</span>
 [query agg]
 (assoc-in query [<span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:aggregations</span>] agg))
</code></pre></div><p>To work with this data structure a few helper methods come in handy when
developing the individual DSL functions. The first function helps when
manipulating lists in a nested map. Basically each scoring function or filter
needs to be added like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn- </span>append-in-nested-list
 <span style="color:#0ff;font-weight:bold">&#34;Given a map, append a new element to a nested  list.&#34;</span>
 [q ks elm]
 (assoc-in q                        <span style="color:#007f7f">; the query</span>
           ks                       <span style="color:#007f7f">; the list of keys in the query</span>
           (<span style="color:#fff;font-weight:bold">apply conj </span>             <span style="color:#007f7f">; append</span>
                  (get-in q ks)     <span style="color:#007f7f">; to the list</span>
                  elm)))            <span style="color:#007f7f">; the new element</span>
</code></pre></div><p>With this basic function adding more expressive functions to manipulate the
specific parts of the query are easy:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn- </span>add-function-score-function
 <span style="color:#0ff;font-weight:bold">&#34;Add a function score function to the query&#34;</span>
 [query fs-function]
 (append-in-nested-list query
                        [<span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:filtered</span> <span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:function_score</span> <span style="color:#0ff;font-weight:bold">:functions</span>]
                        [fs-function]))

(<span style="color:#fff;font-weight:bold">defn- </span>add-must-filter
 <span style="color:#0ff;font-weight:bold">&#34;Add a must filter to the query&#34;</span>
 [query must-filter]
 (append-in-nested-list query
                        [<span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:filtered</span> <span style="color:#0ff;font-weight:bold">:filter</span> <span style="color:#0ff;font-weight:bold">:bool</span> <span style="color:#0ff;font-weight:bold">:must</span>]
                        [must-filter]))

(<span style="color:#fff;font-weight:bold">defn- </span>add-must-not-filter
 <span style="color:#0ff;font-weight:bold">&#34;Add a must filter to the query&#34;</span>
 [query must-filter]
 (append-in-nested-list query
                        [<span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:filtered</span> <span style="color:#0ff;font-weight:bold">:filter</span> <span style="color:#0ff;font-weight:bold">:bool</span> <span style="color:#0ff;font-weight:bold">:must_not</span>]
                        [must-filter]))
</code></pre></div><h3 id="dsl-functions">DSL functions</h3>
<p>The individual functions now basically compose the DSL. Being able to add
<code>(q &quot;merkel&quot;)</code> is translated into the following Clojure function:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn </span>q
  <span style="color:#0ff;font-weight:bold">&#34;Simple query&#34;</span>
  [query user-query]
  (set-query query
             {<span style="color:#0ff;font-weight:bold">:query_string</span> {<span style="color:#0ff;font-weight:bold">:query</span> user-query
                             <span style="color:#0ff;font-weight:bold">:default_operator</span> <span style="color:#0ff;font-weight:bold">&#34;AND&#34;</span>}}))
</code></pre></div><p>Filtering for tags in our dataset (<code>(tags [&quot;merkel&quot;])</code>) is equally trivial:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn </span>tags
  <span style="color:#0ff;font-weight:bold">&#34;Filter for a list of tags&#34;</span>
  [query tags]
  (add-must-filter query {<span style="color:#0ff;font-weight:bold">:terms</span> {<span style="color:#0ff;font-weight:bold">:tags</span> tags}}))
</code></pre></div><p>Freshness seems more complicated but in the end I can simply add a function
score function using an <a href="">exponential decay</a>. With this the user can even
change parameters and see the effects:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn </span>freshness
  <span style="color:#0ff;font-weight:bold">&#34;Add freshness preferences to the query. When called with query and hours as
</span><span style="color:#0ff;font-weight:bold">   arguments&#34;</span>
  [query hours]
  (add-function-score-function query
                               {<span style="color:#0ff;font-weight:bold">:exp</span> {<span style="color:#0ff;font-weight:bold">:publishTime</span> {<span style="color:#0ff;font-weight:bold">:decay</span> <span style="color:#ff0;font-weight:bold">0.9</span>
                                                    <span style="color:#0ff;font-weight:bold">:scale</span> hours}}}))
</code></pre></div><p>Prefering categories over other categories is another function score function.
Basically I add a boost (<code>weight</code>) to all documents matching a certain query:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn </span>prefer-category
  <span style="color:#0ff;font-weight:bold">&#34;Prefer categories over all other categories.&#34;</span>
  [query category-preferences]
  (<span style="color:#fff;font-weight:bold">let </span>[nested-keys [<span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:filtered</span> <span style="color:#0ff;font-weight:bold">:query</span> <span style="color:#0ff;font-weight:bold">:function_score</span> <span style="color:#0ff;font-weight:bold">:functions</span>]
        functions (<span style="color:#fff;font-weight:bold">map </span>(fn[x] {<span style="color:#0ff;font-weight:bold">:filter</span> {<span style="color:#0ff;font-weight:bold">:term</span> {<span style="color:#0ff;font-weight:bold">:category</span> (<span style="color:#fff;font-weight:bold">first </span>x)}}
                               <span style="color:#0ff;font-weight:bold">:weight</span> (<span style="color:#fff;font-weight:bold">second </span>x)})
                       (<span style="color:#fff;font-weight:bold">seq </span>category-preferences))
        existing (get-in query nested-keys)]
    (assoc-in query nested-keys (<span style="color:#fff;font-weight:bold">apply conj </span>existing functions))))
</code></pre></div><p>Aggregations help in understanding the data there is. Classical example in this
case would be getting the number of documents in the result set in a category.
In ES this is a simple terms aggregation:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defn </span>aggregate-categories
 <span style="color:#0ff;font-weight:bold">&#34;Aggregate the result by categories.&#34;</span>
 [query]
 (add-aggregation query {<span style="color:#0ff;font-weight:bold">:terms</span> {<span style="color:#0ff;font-weight:bold">:field</span> <span style="color:#0ff;font-weight:bold">:category</span>}}))
</code></pre></div><p>To tie everything up I need to be able to wrap all functions into one
expression. For this I create a new macro called <code>query</code>:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">defmacro </span>query [&amp; body]
`(<span style="color:#fff;font-weight:bold">-&gt; </span>default-query
     ~@body))
</code></pre></div><p>Using this macro a query can now be defined like this:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">def </span>simple-query (query
                   (q <span style="color:#0ff;font-weight:bold">&#34;test&#34;</span>))
</code></pre></div><h2 id="parsing-the-dsl">Parsing the DSL</h2>
<p>Doing this is Clojure is nice and easy for me but then again I want the PO not
to contact me about getting into the repl. So in the final step I need a
function that converts a string to Clojure code. First I need to parse the
string using <code>read-string</code> and then I can <code>eval</code> the resulting code. For this
to work as expected I need to set the special var <code>*ns*</code> to the namespace of my
DSL functions above using the <code>the-ns</code> function.</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#fff;font-weight:bold">ns </span>demo.dsl)

(<span style="color:#fff;font-weight:bold">defn </span>dsl
 <span style="color:#0ff;font-weight:bold">&#34;Compile the DSL string into code&#34;</span>
 [dsl-string]
 (<span style="color:#fff;font-weight:bold">binding </span>[*ns* (the-ns <span style="color:#0ff;font-weight:bold">&#39;demo.dsl-functions</span>)
           *read-eval* false]
  (<span style="color:#fff;font-weight:bold">eval </span>(read-string dsl-string))))
</code></pre></div><p>The <code>binding</code> form binds the special var <code>*ns*</code> to the namespace containing my
dsl functions. I also bind <code>*read-eval*</code> to false and by this disable the
<code>eval</code> function inside the string. The parsed string will have access to all
functions declared in there. <code>read-string</code> converts a string into Clojure code
and <code>eval</code> will execute it. In this case it will simply return the final
Elasticsearch query.</p>
<h2 id="result">Result</h2>
<p>In essence this allows me to have a web frontend where a user can input
the query from the beginning</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(query
 (freshness <span style="color:#0ff;font-weight:bold">&#34;1h&#34;</span>)
 (tags [<span style="color:#0ff;font-weight:bold">&#34;politics&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;sports&#34;</span>])
 (prefer-category {<span style="color:#0ff;font-weight:bold">&#34;politics&#34;</span> <span style="color:#ff0;font-weight:bold">2</span>,
                   <span style="color:#0ff;font-weight:bold">&#34;sports&#34;</span> <span style="color:#ff0;font-weight:bold">0.5</span>}))
</code></pre></div><p>get back the equivalent Elasticsearch query:</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">{<span style="color:#0ff;font-weight:bold">:query</span>
 {<span style="color:#0ff;font-weight:bold">:filtered</span>
  {<span style="color:#0ff;font-weight:bold">:query</span>
   {<span style="color:#0ff;font-weight:bold">:function_score</span>
    {<span style="color:#0ff;font-weight:bold">:query</span> {},
     <span style="color:#0ff;font-weight:bold">:functions</span>
     [{<span style="color:#0ff;font-weight:bold">:exp</span> {<span style="color:#0ff;font-weight:bold">:publishTime</span> {<span style="color:#0ff;font-weight:bold">:decay</span> <span style="color:#ff0;font-weight:bold">0.9</span>, <span style="color:#0ff;font-weight:bold">:scale</span> <span style="color:#0ff;font-weight:bold">&#34;1h&#34;</span>}}}
      {<span style="color:#0ff;font-weight:bold">:filter</span> {<span style="color:#0ff;font-weight:bold">:term</span> {<span style="color:#0ff;font-weight:bold">:category</span> <span style="color:#0ff;font-weight:bold">&#34;politics&#34;</span>}}, <span style="color:#0ff;font-weight:bold">:weight</span> <span style="color:#ff0;font-weight:bold">2</span>}
      {<span style="color:#0ff;font-weight:bold">:filter</span> {<span style="color:#0ff;font-weight:bold">:term</span> {<span style="color:#0ff;font-weight:bold">:category</span> <span style="color:#0ff;font-weight:bold">&#34;sports&#34;</span>}}, <span style="color:#0ff;font-weight:bold">:weight</span> <span style="color:#ff0;font-weight:bold">0.5</span>}]}},
   <span style="color:#0ff;font-weight:bold">:filter</span>
   {<span style="color:#0ff;font-weight:bold">:bool</span>
    {<span style="color:#0ff;font-weight:bold">:must</span> [{<span style="color:#0ff;font-weight:bold">:terms</span> {<span style="color:#0ff;font-weight:bold">:tags</span> [<span style="color:#0ff;font-weight:bold">&#34;politics&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;sports&#34;</span>]}}], <span style="color:#0ff;font-weight:bold">:must_not</span> []}}}},
 <span style="color:#0ff;font-weight:bold">:aggregations</span> {}}
</code></pre></div><p>which I can execute in the backend and display the results. With all the domain
functions in place I can then keep on improving the DSL or the frontend and
enable the PO to experiment at lot easier without my direct involvement, at
least in parts that I am not really interested in.</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
      
        © 2015 - 2020
      
       Daniel Truemper 
    
    
       · 
      Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
    
  </section>
</footer>

    </main>

    

    

  </body>

</html>
