<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>all things considered: Elasticsearch DSL-DSL</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,600italic,600,400' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css">
    <link href="../css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/index.html">all things considered</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li
                ><a href="/archives.html"><i class="fa fa-archive"></i> Archives</a></li>
                
                <li
                >
                    <a href="/pages/about.html">
                        
                        <i class="fa fa-info"></i>&nbsp;
                        
                        About
                    </a>
                </li>
                
                <li><a href="/feed.xml"><i class="fa fa-rss"></i> RSS</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div><!--/.container-fluid -->
</nav>


<div class="container">

    <div class="row">
        <div class="col-lg-9">
            <div id="content">
                
<div id="post">
    <div id="post-header">
    <div id="post-meta" class="row">
        <div class="col-lg-6">July 10, 2015</div>
        
    </div>
    <h2>Elasticsearch DSL-DSL</h2>
</div>
<div>
    
    <p>Elasticsearch is a search server based on Apache Lucene. As a developer it is easy to use, has an expressive query DSL and all is based on JSON serialization. Often though I find myself in a position where I need to adapt queries frequently and non-trivially, say in a demonstration in front of customers or product owners.</p><p>The questions are mostly similar: "what if I also filter for X", "how does the ranking change, when I add a freshness function", "do I get a better result if I boost document types Y" and so on. While these are easy to add, two things bother me: first, I need to come up with the queries during a presentation, which adds pauses to the meetings. When I'm finished with the query the discussion has evolved. Second, I don't want to be the enabler. If they can find out what they want without me it also means a faster feedback loop for them. In brainstorming sessions it is easy to focus on arguments and skip the sometimes lengthy query finding pauses. Win win for everyone it seems.</p><p>For this I have startet working on <strong>meta-DSLs</strong> for Elasticsearch projects. The idea is simple: given a base query I want to be able to quickly alter or enhance it using simple functions that are aligned with the mapping and index structure. Given my current addiction towards Clojure, this is what I've come up with:</p><pre><code class="clojure">&#40;query
 &#40;freshness &quot;1h&quot;&#41;
 &#40;tags &#91;&quot;politics&quot; &quot;sports&quot;&#93;&#41;
 &#40;prefer-category {&quot;politics&quot; 2,
                   &quot;sports&quot; 0.5}&#41;&#41;
</code></pre><p>Ok, it's not yet a graphical interface, but it is a start. And it's intuitive. After demonstrating this to customers a few times they like it and request more features. Their own feedback loop has shortened considerably. And the best of it is that I am out of the loop and can focus on adding features.</p><p>In this example the domain will be news articles. They have a title, tags, a published time and categories. Something like this:</p><pre><code class="clojure">{
    :title &quot;The news&quot;
    :tags &#91;&quot;obama&quot; &quot;kerry&quot; &quot;merkel&quot;&#93;
    :timestamp &quot;2015-07-28T10:00:00Z&quot;
    :category &#91;&quot;politics&quot;&#93;
}
</code></pre><p>This post is my story of how I implemented this. Publishing this as a library might be an idea but in the end all of this is tied to an exact mapping, index structure and use case. If there is interest though, starting something similar in a library could be interesting, if there is interest.</p><h2><a name="dsls&#95;in&#95;clojure"></a>DSLs in Clojure</h2><p>Creating a Domain Specific Language is pretty straight forward in Clojure assuming you expose Clojure or Lisp syntax to the user. Using the clojure reader and <code>eval</code> parsing a DSL into Clojure code is simple and defining the DSL itself does then only involve implementing the functions.</p><p>In the next part I focus on the DSL implementation itself and the functions for manipulating the query. In the last section, parsing and evaluating the DSL into a real Elasticsearch query finishes.</p><h2><a name="the&#95;dsl"></a>The DSL</h2><p>For the custom DSL I started with a base query structure upon which all other functions build. It has four parts: query, scoring, filtering and aggregations:</p><pre><code class="clojure">&#40;def default-query
 {:query
  {:filtered
   {:query {:function&#95;score {:query {}
                             :functions &#91;&#93;}}
    :filter {:bool {:must &#91;&#93;
                    :must&#95;not &#91;&#93;}}}}
  :aggregations {}}&#41;
</code></pre><p>For all functions I am assuming the query to be the first argument in all functions working with it. This simplifies the code later on as I can use the <code>thread-first</code> macro to chain the individual function call.</p><p>Defining a function to add a <code>query</code> and for adding aggregations is straight forward and does not even need a helper function:</p><pre><code class="clojure">&#40;defn- set-query
 &quot;Given a valid ES query `q` add this to the generated query and return the
  new version.&quot;
 &#91;query q&#93;
 &#40;assoc-in query &#91;:query :filtered :query :function&#95;score :query&#93; q&#41;&#41;

&#40;defn- add-aggregation
 &quot;Add a new aggregation to the query&quot;
 &#91;query agg&#93;
 &#40;assoc-in query &#91;:query :aggregations&#93; agg&#41;&#41;
</code></pre><p>To work with this data structure a few helper methods come in handy when developing the individual DSL functions. The first function helps when manipulating lists in a nested map. Basically each scoring function or filter needs to be added like this:</p><pre><code class="clojure">&#40;defn- append-in-nested-list
 &quot;Given a map, append a new element to a nested  list.&quot;
 &#91;q ks elm&#93;
 &#40;assoc-in q                        ; the query
           ks                       ; the list of keys in the query
           &#40;apply conj              ; append
                  &#40;get-in q ks&#41;     ; to the list
                  elm&#41;&#41;&#41;            ; the new element
</code></pre><p>With this basic function adding more expressive functions to manipulate the specific parts of the query are easy:</p><pre><code class="clojure">&#40;defn- add-function-score-function
 &quot;Add a function score function to the query&quot;
 &#91;query fs-function&#93;
 &#40;append-in-nested-list query
                        &#91;:query :filtered :query :function&#95;score :functions&#93;
                        &#91;fs-function&#93;&#41;&#41;

&#40;defn- add-must-filter
 &quot;Add a must filter to the query&quot;
 &#91;query must-filter&#93;
 &#40;append-in-nested-list query
                        &#91;:query :filtered :filter :bool :must&#93;
                        &#91;must-filter&#93;&#41;&#41;

&#40;defn- add-must-not-filter
 &quot;Add a must filter to the query&quot;
 &#91;query must-filter&#93;
 &#40;append-in-nested-list query
                        &#91;:query :filtered :filter :bool :must&#95;not&#93;
                        &#91;must-filter&#93;&#41;&#41;
</code></pre><h3><a name="dsl&#95;functions"></a>DSL functions</h3><p>The individual functions now basically compose the DSL. Being able to add <code>&#40;q &quot;merkel&quot;&#41;</code> is translated into the following Clojure function:</p><pre><code class="clojure">&#40;defn q
  &quot;Simple query&quot;
  &#91;query user-query&#93;
  &#40;set-query query
             {:query&#95;string {:query user-query
                             :default&#95;operator &quot;AND&quot;}}&#41;&#41;
</code></pre><p>Filtering for tags in our dataset (<code>&#40;tags &#91;&quot;merkel&quot;&#93;&#41;</code>) is equally trivial:</p><pre><code class="clojure">&#40;defn tags
  &quot;Filter for a list of tags&quot;
  &#91;query tags&#93;
  &#40;add-must-filter query {:terms {:tags tags}}&#41;&#41;
</code></pre><p>Freshness seems more complicated but in the end I can simply add a function score function using an [exponential decay](). With this the user can even change parameters and see the effects:</p><pre><code class="clojure">&#40;defn freshness
  &quot;Add freshness preferences to the query. When called with query and hours as
   arguments&quot;
  &#91;query hours&#93;
  &#40;add-function-score-function query
                               {:exp {:publishTime {:decay 0.9
                                                    :scale hours}}}&#41;&#41;
</code></pre><p>Prefering categories over other categories is another function score function. Basically I add a boost (<code>weight</code>) to all documents matching a certain query:</p><pre><code class="clojure">&#40;defn prefer-category
  &quot;Prefer categories over all other categories.&quot;
  &#91;query category-preferences&#93;
  &#40;let &#91;nested-keys &#91;:query :filtered :query :function&#95;score :functions&#93;
        functions &#40;map &#40;fn&#91;x&#93; {:filter {:term {:category &#40;first x&#41;}}
                               :weight &#40;second x&#41;}&#41;
                       &#40;seq category-preferences&#41;&#41;
        existing &#40;get-in query nested-keys&#41;&#93;
    &#40;assoc-in query nested-keys &#40;apply conj existing functions&#41;&#41;&#41;&#41;
</code></pre><p>Aggregations help in understanding the data there is. Classical example in this case would be getting the number of documents in the result set in a category. In ES this is a simple terms aggregation:</p><pre><code class="clojure">&#40;defn aggregate-categories
 &quot;Aggregate the result by categories.&quot;
 &#91;query&#93;
 &#40;add-aggregation query {:terms {:field :category}}&#41;&#41;
</code></pre><p>To tie everything up I need to be able to wrap all functions into one expression. For this I create a new macro called <code>query</code>:</p><pre><code class="clojure">&#40;defmacro query &#91;&amp; body&#93;
`&#40;-&gt; default-query
     &#126;@body&#41;&#41;
</code></pre><p>Using this macro a query can now be defined like this:</p><pre><code class="clojure">&#40;def simple-query &#40;query
                   &#40;q &quot;test&quot;&#41;&#41;
</code></pre><h2><a name="parsing&#95;the&#95;dsl"></a>Parsing the DSL</h2><p>Doing this is Clojure is nice and easy for me but then again I want the PO not to contact me about getting into the repl. So in the final step I need a function that converts a string to Clojure code. First I need to parse the string using <code>read-string</code> and then I can <code>eval</code> the resulting code. For this to work as expected I need to set the special var <code>&#42;ns&#42;</code> to the namespace of my DSL functions above using the <code>the-ns</code> function.</p><pre><code class="clojure">&#40;ns demo.dsl&#41;

&#40;defn dsl
 &quot;Compile the DSL string into code&quot;
 &#91;dsl-string&#93;
 &#40;binding &#91;&#42;ns&#42; &#40;the-ns 'demo.dsl-functions&#41;
           &#42;read-eval&#42; false&#93;
  &#40;eval &#40;read-string dsl-string&#41;&#41;&#41;&#41;
</code></pre><p>The <code>binding</code> form binds the special var <code>&#42;ns&#42;</code> to the namespace containing my dsl functions. I also bind <code>&#42;read-eval&#42;</code> to false and by this disable the <code>eval</code> function inside the string. The parsed string will have access to all functions declared in there. <code>read-string</code> converts a string into Clojure code and <code>eval</code> will execute it. In this case it will simply return the final Elasticsearch query.</p><h2><a name="result"></a>Result</h2><p>In essence this allows me to have a web frontend where a user can input the query from the beginning</p><pre><code class="clojure">&#40;query
 &#40;freshness &quot;1h&quot;&#41;
 &#40;tags &#91;&quot;politics&quot; &quot;sports&quot;&#93;&#41;
 &#40;prefer-category {&quot;politics&quot; 2,
                   &quot;sports&quot; 0.5}&#41;&#41;
</code></pre><p>get back the equivalent Elasticsearch query:</p><pre><code class="clojure">{:query
 {:filtered
  {:query
   {:function&#95;score
    {:query {},
     :functions
     &#91;{:exp {:publishTime {:decay 0.9, :scale &quot;1h&quot;}}}
      {:filter {:term {:category &quot;politics&quot;}}, :weight 2}
      {:filter {:term {:category &quot;sports&quot;}}, :weight 0.5}&#93;}},
   :filter
   {:bool
    {:must &#91;{:terms {:tags &#91;&quot;politics&quot; &quot;sports&quot;&#93;}}&#93;, :must&#95;not &#91;&#93;}}}},
 :aggregations {}}
</code></pre><p>which I can execute in the backend and display the results. With all the domain functions in place I can then keep on improving the DSL or the frontend and enable the PO to experiment at lot easier without my direct involvement, at least in parts that I am not really interested in.</p>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags/dsl.html">dsl</a>
    
    <a href="/tags/clojure.html">clojure</a>
    
    <a href="/tags/elasticsearch.html">elasticsearch</a>
    
</div>


    <div id="prev-next">
        
        
        <a class="right" href="/posts/2015-06-10-init.html">Start a blog &raquo;</a>
        
    </div>

    


</div>

            </div>
        </div>

        <div class="col-md-3">
            <div id="sidebar">
                <h3>Links</h3>
                <ul id="links" class="list-unstyled">
                    <li><a href="https://twitter.com/truemped"><i class="fa fa-twitter"></i> @truemped</a></li>
                    <li><a href="https://github.com/truemped"><i class="fa fa-github"></i> truemped</a></li>
                    
                </ul>
                
                <div id="recent">
                    <h3>Recent Posts</h3>
                    <ul>
                        
                        <li><a href="/posts/2015-07-10-elastic-dsl.html">Elasticsearch DSL-DSL</a></li>
                        
                        <li><a href="/posts/2015-06-10-init.html">Start a blog</a></li>
                        
                    </ul>
                </div>
                
                
                <div id="tags">
                    <h3>Tags</h3>
                    <ul>
                        
                        <li><a href="/tags/elasticsearch.html">elasticsearch</a></li>
                        
                        <li><a href="/tags/clojure.html">clojure</a></li>
                        
                        <li><a href="/tags/dsl.html">dsl</a></li>
                        
                    </ul>
                </div>
                
            </div>
        </div>
    </div>
    <footer>Copyright &copy; 2015 Daniel Truemper
        <p style="text-align: center;">Powered by <a href="http://cryogenweb.org">Cryogen</a></p></footer>
</div>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
<script src="../js/highlight.pack.js" type="text/javascript"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-64224815-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>
