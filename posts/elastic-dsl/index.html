<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Elasticsearch DSL-DSL">
<meta itemprop="description" content="Elasticsearch is a search server based on Apache Lucene. As a developer it is easy to use, has an expressive query DSL and all is based on JSON serialization. Often though I find myself in a position where I need to adapt queries frequently and non-trivially, say in a demonstration in front of customers or product owners.
The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if I boost document types Y&rdquo; and so on.">


<meta itemprop="datePublished" content="2015-07-29T10:19:47&#43;01:00" />
<meta itemprop="dateModified" content="2015-07-29T10:19:47&#43;01:00" />
<meta itemprop="wordCount" content="1375">



<meta itemprop="keywords" content="clojure,elasticsearch," />
<meta property="og:title" content="Elasticsearch DSL-DSL" />
<meta property="og:description" content="Elasticsearch is a search server based on Apache Lucene. As a developer it is easy to use, has an expressive query DSL and all is based on JSON serialization. Often though I find myself in a position where I need to adapt queries frequently and non-trivially, say in a demonstration in front of customers or product owners.
The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if I boost document types Y&rdquo; and so on." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/elastic-dsl/" />
<meta property="article:published_time" content="2015-07-29T10:19:47&#43;01:00"/>
<meta property="article:modified_time" content="2015-07-29T10:19:47&#43;01:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Elasticsearch DSL-DSL"/>
<meta name="twitter:description" content="Elasticsearch is a search server based on Apache Lucene. As a developer it is easy to use, has an expressive query DSL and all is based on JSON serialization. Often though I find myself in a position where I need to adapt queries frequently and non-trivially, say in a demonstration in front of customers or product owners.
The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if I boost document types Y&rdquo; and so on."/>
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Elasticsearch DSL-DSL</title>
	<link rel="stylesheet" href="/css/style.min.b7620e512c50d304a35bc56080a7c71cf37e6d436788004505845869e99aca61.css" integrity="sha256-t2IOUSxQ0wSjW8VggKfHHPN+bUNniABFBYRYaemaymE=">
	
	<link rel="stylesheet" href="/css/syntax.css">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="/">all things considered...</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					<a href="/posts/">Posts</a>
					<a href="/about/">About</a>
				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://twitter.com/truemped" target="_blank" rel="noopener" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://github.com/truemped" target="_blank" rel="noopener" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://www.linkedin.com/in/daniel-truemper-78571015/" target="_blank" rel="noopener" title="Linkedin"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="/posts/">Posts</a></li>
			<li><a href="/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jul 29, 2015</span></div>
				<h1>Elasticsearch DSL-DSL</h1>
			</header>
			<div class="content">
				

<p>Elasticsearch is a search server based on Apache Lucene. As a developer it is
easy to use, has an expressive query DSL and all is based on JSON
serialization. Often though I find myself in a position where I need to adapt
queries frequently and non-trivially, say in a demonstration in front of
customers or product owners.</p>

<p>The questions are mostly similar: &ldquo;what if I also filter for X&rdquo;, &ldquo;how does the
ranking change, when I add a freshness function&rdquo;, &ldquo;do I get a better result if
I boost document types Y&rdquo; and so on. While these are easy to add, two things
bother me: first, I need to come up with the queries during a presentation,
which adds pauses to the meetings. When I&rsquo;m finished with the query the
discussion has evolved. Second, I don&rsquo;t want to be the enabler. If they can
find out what they want without me it also means a faster feedback loop for
them. In brainstorming sessions it is easy to focus on arguments and skip the
sometimes lengthy query finding pauses. Win win for everyone it seems.</p>

<p>For this I have startet working on <strong>meta-DSLs</strong> for Elasticsearch projects.
The idea is simple: given a base query I want to be able to quickly alter or
enhance it using simple functions that are aligned with the mapping and index
structure. Given my current addiction towards Clojure, this is what I&rsquo;ve come
up with:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nv">query</span>
 <span class="p">(</span><span class="nv">freshness</span> <span class="s">&#34;1h&#34;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">tags</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span> <span class="s">&#34;sports&#34;</span><span class="p">])</span>
 <span class="p">(</span><span class="nv">prefer-category</span> <span class="p">{</span><span class="s">&#34;politics&#34;</span> <span class="mi">2</span>,
                   <span class="s">&#34;sports&#34;</span> <span class="mf">0.5</span><span class="p">}))</span></code></pre></div>
<p>Ok, it&rsquo;s not yet a graphical interface, but it is a start. And it&rsquo;s intuitive.
After demonstrating this to customers a few times they like it and request more
features. Their own feedback loop has shortened considerably. And the best of
it is that I am out of the loop and can focus on adding features.</p>

<p>In this example the domain will be news articles. They have a title, tags, a
published time and categories. Something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">{</span>
    <span class="ss">:title</span> <span class="s">&#34;The news&#34;</span>
    <span class="ss">:tags</span> <span class="p">[</span><span class="s">&#34;obama&#34;</span> <span class="s">&#34;kerry&#34;</span> <span class="s">&#34;merkel&#34;</span><span class="p">]</span>
    <span class="ss">:timestamp</span> <span class="s">&#34;2015-07-28T10:00:00Z&#34;</span>
    <span class="ss">:category</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>
<p>This post is my story of how I implemented this. Publishing this as a library
might be an idea but in the end all of this is tied to an exact mapping, index
structure and use case. If there is interest though, starting something similar
in a library could be interesting, if there is interest.</p>

<h2 id="dsls-in-clojure">DSLs in Clojure</h2>

<p>Creating a Domain Specific Language is pretty straight forward in Clojure
assuming you expose Clojure or Lisp syntax to the user. Using the clojure
reader and <code>eval</code> parsing a DSL into Clojure code is simple and defining the
DSL itself does then only involve implementing the functions.</p>

<p>In the next part I focus on the DSL implementation itself and the functions for
manipulating the query. In the last section, parsing and evaluating the DSL
into a real Elasticsearch query finishes.</p>

<h2 id="the-dsl">The DSL</h2>

<p>For the custom DSL I started with a base query structure upon which all other
functions build. It has four parts: query, scoring, filtering and aggregations:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">default-query</span>
 <span class="p">{</span><span class="ss">:query</span>
  <span class="p">{</span><span class="ss">:filtered</span>
   <span class="p">{</span><span class="ss">:query</span> <span class="p">{</span><span class="ss">:function_score</span> <span class="p">{</span><span class="ss">:query</span> <span class="p">{}</span>
                             <span class="ss">:functions</span> <span class="p">[]}}</span>
    <span class="ss">:filter</span> <span class="p">{</span><span class="ss">:bool</span> <span class="p">{</span><span class="ss">:must</span> <span class="p">[]</span>
                    <span class="ss">:must_not</span> <span class="p">[]}}}}</span>
  <span class="ss">:aggregations</span> <span class="p">{}})</span></code></pre></div>
<p>For all functions I am assuming the query to be the first argument in all
functions working with it. This simplifies the code later on as I can use the
<code>thread-first</code> macro to chain the individual function call.</p>

<p>Defining a function to add a <code>query</code> and for adding aggregations is straight
forward and does not even need a helper function:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn- </span><span class="nv">set-query</span>
 <span class="s">&#34;Given a valid ES query `q` add this to the generated query and return the
</span><span class="s">  new version.&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">q</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">query</span> <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:query</span> <span class="ss">:function_score</span> <span class="ss">:query</span><span class="p">]</span> <span class="nv">q</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">add-aggregation</span>
 <span class="s">&#34;Add a new aggregation to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">agg</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">query</span> <span class="p">[</span><span class="ss">:query</span> <span class="ss">:aggregations</span><span class="p">]</span> <span class="nv">agg</span><span class="p">))</span></code></pre></div>
<p>To work with this data structure a few helper methods come in handy when
developing the individual DSL functions. The first function helps when
manipulating lists in a nested map. Basically each scoring function or filter
needs to be added like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn- </span><span class="nv">append-in-nested-list</span>
 <span class="s">&#34;Given a map, append a new element to a nested  list.&#34;</span>
 <span class="p">[</span><span class="nv">q</span> <span class="nv">ks</span> <span class="nv">elm</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">q</span>                        <span class="c1">; the query</span>
           <span class="nv">ks</span>                       <span class="c1">; the list of keys in the query</span>
           <span class="p">(</span><span class="nb">apply conj </span>             <span class="c1">; append</span>
                  <span class="p">(</span><span class="nv">get-in</span> <span class="nv">q</span> <span class="nv">ks</span><span class="p">)</span>     <span class="c1">; to the list</span>
                  <span class="nv">elm</span><span class="p">)))</span>            <span class="c1">; the new element</span></code></pre></div>
<p>With this basic function adding more expressive functions to manipulate the
specific parts of the query are easy:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn- </span><span class="nv">add-function-score-function</span>
 <span class="s">&#34;Add a function score function to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">fs-function</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">append-in-nested-list</span> <span class="nv">query</span>
                        <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:query</span> <span class="ss">:function_score</span> <span class="ss">:functions</span><span class="p">]</span>
                        <span class="p">[</span><span class="nv">fs-function</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">add-must-filter</span>
 <span class="s">&#34;Add a must filter to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">must-filter</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">append-in-nested-list</span> <span class="nv">query</span>
                        <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:filter</span> <span class="ss">:bool</span> <span class="ss">:must</span><span class="p">]</span>
                        <span class="p">[</span><span class="nv">must-filter</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn- </span><span class="nv">add-must-not-filter</span>
 <span class="s">&#34;Add a must filter to the query&#34;</span>
 <span class="p">[</span><span class="nv">query</span> <span class="nv">must-filter</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">append-in-nested-list</span> <span class="nv">query</span>
                        <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:filter</span> <span class="ss">:bool</span> <span class="ss">:must_not</span><span class="p">]</span>
                        <span class="p">[</span><span class="nv">must-filter</span><span class="p">]))</span></code></pre></div>
<h3 id="dsl-functions">DSL functions</h3>

<p>The individual functions now basically compose the DSL. Being able to add
<code>(q &quot;merkel&quot;)</code> is translated into the following Clojure function:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">q</span>
  <span class="s">&#34;Simple query&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">user-query</span><span class="p">]</span>
  <span class="p">(</span><span class="nv">set-query</span> <span class="nv">query</span>
             <span class="p">{</span><span class="ss">:query_string</span> <span class="p">{</span><span class="ss">:query</span> <span class="nv">user-query</span>
                             <span class="ss">:default_operator</span> <span class="s">&#34;AND&#34;</span><span class="p">}}))</span></code></pre></div>
<p>Filtering for tags in our dataset (<code>(tags [&quot;merkel&quot;])</code>) is equally trivial:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">tags</span>
  <span class="s">&#34;Filter for a list of tags&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">tags</span><span class="p">]</span>
  <span class="p">(</span><span class="nv">add-must-filter</span> <span class="nv">query</span> <span class="p">{</span><span class="ss">:terms</span> <span class="p">{</span><span class="ss">:tags</span> <span class="nv">tags</span><span class="p">}}))</span></code></pre></div>
<p>Freshness seems more complicated but in the end I can simply add a function
score function using an [exponential decay](). With this the user can even
change parameters and see the effects:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">freshness</span>
  <span class="s">&#34;Add freshness preferences to the query. When called with query and hours as
</span><span class="s">   arguments&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">hours</span><span class="p">]</span>
  <span class="p">(</span><span class="nv">add-function-score-function</span> <span class="nv">query</span>
                               <span class="p">{</span><span class="ss">:exp</span> <span class="p">{</span><span class="ss">:publishTime</span> <span class="p">{</span><span class="ss">:decay</span> <span class="mf">0.9</span>
                                                    <span class="ss">:scale</span> <span class="nv">hours</span><span class="p">}}}))</span></code></pre></div>
<p>Prefering categories over other categories is another function score function.
Basically I add a boost (<code>weight</code>) to all documents matching a certain query:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">prefer-category</span>
  <span class="s">&#34;Prefer categories over all other categories.&#34;</span>
  <span class="p">[</span><span class="nv">query</span> <span class="nv">category-preferences</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">nested-keys</span> <span class="p">[</span><span class="ss">:query</span> <span class="ss">:filtered</span> <span class="ss">:query</span> <span class="ss">:function_score</span> <span class="ss">:functions</span><span class="p">]</span>
        <span class="nv">functions</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nv">fn</span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">{</span><span class="ss">:filter</span> <span class="p">{</span><span class="ss">:term</span> <span class="p">{</span><span class="ss">:category</span> <span class="p">(</span><span class="nb">first </span><span class="nv">x</span><span class="p">)}}</span>
                               <span class="ss">:weight</span> <span class="p">(</span><span class="nb">second </span><span class="nv">x</span><span class="p">)})</span>
                       <span class="p">(</span><span class="nb">seq </span><span class="nv">category-preferences</span><span class="p">))</span>
        <span class="nv">existing</span> <span class="p">(</span><span class="nv">get-in</span> <span class="nv">query</span> <span class="nv">nested-keys</span><span class="p">)]</span>
    <span class="p">(</span><span class="nv">assoc-in</span> <span class="nv">query</span> <span class="nv">nested-keys</span> <span class="p">(</span><span class="nb">apply conj </span><span class="nv">existing</span> <span class="nv">functions</span><span class="p">))))</span></code></pre></div>
<p>Aggregations help in understanding the data there is. Classical example in this
case would be getting the number of documents in the result set in a category.
In ES this is a simple terms aggregation:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defn </span><span class="nv">aggregate-categories</span>
 <span class="s">&#34;Aggregate the result by categories.&#34;</span>
 <span class="p">[</span><span class="nv">query</span><span class="p">]</span>
 <span class="p">(</span><span class="nv">add-aggregation</span> <span class="nv">query</span> <span class="p">{</span><span class="ss">:terms</span> <span class="p">{</span><span class="ss">:field</span> <span class="ss">:category</span><span class="p">}}))</span></code></pre></div>
<p>To tie everything up I need to be able to wrap all functions into one
expression. For this I create a new macro called <code>query</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">query</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
<span class="o">`</span><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">default-query</span>
     <span class="o">~@</span><span class="nv">body</span><span class="p">))</span></code></pre></div>
<p>Using this macro a query can now be defined like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">def </span><span class="nv">simple-query</span> <span class="p">(</span><span class="nv">query</span>
                   <span class="p">(</span><span class="nv">q</span> <span class="s">&#34;test&#34;</span><span class="p">))</span></code></pre></div>
<h2 id="parsing-the-dsl">Parsing the DSL</h2>

<p>Doing this is Clojure is nice and easy for me but then again I want the PO not
to contact me about getting into the repl. So in the final step I need a
function that converts a string to Clojure code. First I need to parse the
string using <code>read-string</code> and then I can <code>eval</code> the resulting code. For this
to work as expected I need to set the special var <code>*ns*</code> to the namespace of my
DSL functions above using the <code>the-ns</code> function.</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="kd">ns </span><span class="nv">demo.dsl</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">dsl</span>
 <span class="s">&#34;Compile the DSL string into code&#34;</span>
 <span class="p">[</span><span class="nv">dsl-string</span><span class="p">]</span>
 <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*ns*</span> <span class="p">(</span><span class="nv">the-ns</span> <span class="ss">&#39;demo.dsl-functions</span><span class="p">)</span>
           <span class="nv">*read-eval*</span> <span class="nv">false</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nv">read-string</span> <span class="nv">dsl-string</span><span class="p">))))</span></code></pre></div>
<p>The <code>binding</code> form binds the special var <code>*ns*</code> to the namespace containing my
dsl functions. I also bind <code>*read-eval*</code> to false and by this disable the
<code>eval</code> function inside the string. The parsed string will have access to all
functions declared in there. <code>read-string</code> converts a string into Clojure code
and <code>eval</code> will execute it. In this case it will simply return the final
Elasticsearch query.</p>

<h2 id="result">Result</h2>

<p>In essence this allows me to have a web frontend where a user can input
the query from the beginning</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nv">query</span>
 <span class="p">(</span><span class="nv">freshness</span> <span class="s">&#34;1h&#34;</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">tags</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span> <span class="s">&#34;sports&#34;</span><span class="p">])</span>
 <span class="p">(</span><span class="nv">prefer-category</span> <span class="p">{</span><span class="s">&#34;politics&#34;</span> <span class="mi">2</span>,
                   <span class="s">&#34;sports&#34;</span> <span class="mf">0.5</span><span class="p">}))</span></code></pre></div>
<p>get back the equivalent Elasticsearch query:</p>
<div class="highlight"><pre class="chroma"><code class="language-clojure" data-lang="clojure"><span class="p">{</span><span class="ss">:query</span>
 <span class="p">{</span><span class="ss">:filtered</span>
  <span class="p">{</span><span class="ss">:query</span>
   <span class="p">{</span><span class="ss">:function_score</span>
    <span class="p">{</span><span class="ss">:query</span> <span class="p">{}</span>,
     <span class="ss">:functions</span>
     <span class="p">[{</span><span class="ss">:exp</span> <span class="p">{</span><span class="ss">:publishTime</span> <span class="p">{</span><span class="ss">:decay</span> <span class="mf">0.9</span>, <span class="ss">:scale</span> <span class="s">&#34;1h&#34;</span><span class="p">}}}</span>
      <span class="p">{</span><span class="ss">:filter</span> <span class="p">{</span><span class="ss">:term</span> <span class="p">{</span><span class="ss">:category</span> <span class="s">&#34;politics&#34;</span><span class="p">}}</span>, <span class="ss">:weight</span> <span class="mi">2</span><span class="p">}</span>
      <span class="p">{</span><span class="ss">:filter</span> <span class="p">{</span><span class="ss">:term</span> <span class="p">{</span><span class="ss">:category</span> <span class="s">&#34;sports&#34;</span><span class="p">}}</span>, <span class="ss">:weight</span> <span class="mf">0.5</span><span class="p">}]}}</span>,
   <span class="ss">:filter</span>
   <span class="p">{</span><span class="ss">:bool</span>
    <span class="p">{</span><span class="ss">:must</span> <span class="p">[{</span><span class="ss">:terms</span> <span class="p">{</span><span class="ss">:tags</span> <span class="p">[</span><span class="s">&#34;politics&#34;</span> <span class="s">&#34;sports&#34;</span><span class="p">]}}]</span>, <span class="ss">:must_not</span> <span class="p">[]}}}}</span>,
 <span class="ss">:aggregations</span> <span class="p">{}}</span></code></pre></div>
<p>which I can execute in the backend and display the results. With all the domain
functions in place I can then keep on improving the DSL or the frontend and
enable the PO to experiment at lot easier without my direct involvement, at
least in parts that I am not really interested in.</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="/tags/clojure">clojure</a></span><span class="tag"><a href="/tags/elasticsearch">elasticsearch</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>1375 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2015-07-29 11:19 &#43;0200</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="/posts/infra/varnish-all-the-things/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Varnish All the Things</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="/">Daniel Truemper</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="/js/main.min.8f39f24808e9d0a9b02da58c2d2838da859dc0b7bdfadbdb1883aae8b6adacfe.js" integrity="sha256-jznySAjp0KmwLaWMLSg42oWdwLe9+tvbGIOq6LatrP4="></script>

</body>

</html>
